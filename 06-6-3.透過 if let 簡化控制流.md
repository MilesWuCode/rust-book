# 透過 if let 簡化控制流

如果數值為 Some，我們就在分支中綁定 max 變數，印出 Some 變體內的數值。我們不想對 None 作任何事情。為了滿足 match 表達式，我們必須在只處理一種變體的分支後面，再加上 \_ => ()。這樣就加了不少樣板程式碼。

```rust
fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("最大值被設為 {}", max),
        _ => (),
    }
}
```

不過我們可以使用 if let 以更精簡的方式寫出來

if let 接收一個模式與一個表達式，然後用等號區隔開來。它與 match 的運作方式相同，表達式的意義與 match 相同，然後前面的模式就是第一個分支。 在此例中的模式就是 Some(max)，然後 max 會綁定 Some 內的數值。我們就和 match 分支中使用 max 一樣，在 if let 區塊的本體中使用 max。如果數值沒有配對到模式，if let 中的程式碼就不會執行。

使用 if let 可以少打些字、減少縮排以及不用寫多餘的樣板程式碼。不過你就少了 match 強制的徹底窮舉檢查。要何時選擇 match 還是 if let 得依據你在的場合是要做什麼事情，以及在精簡度與徹底檢查之間做取捨。

換句話說，你可以想像 if let 是 match 的語法糖（syntax sugar），它只會配對一種模式來執行程式碼並忽略其他數值。

```rust
fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("最大值被設為 {}", max);
    }
}
```

我們也可以在 if let 之後加上 else，else 之後的程式碼區塊等同於 match 表達式中 \_ 情形的程式碼區塊。這樣一來的 if let 和 else 組合就等同於 match 了。

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --省略--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("此 25 美分所屬的州為 {:?}!", state),
        _ => count += 1,
    }
}
```

或是我們也可以用 if let 和 else 表達式這樣寫

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --省略--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("此 25 美分所屬的州為 {:?}!", state);
    } else {
        count += 1;
    }
}
```

我們現在涵蓋了如何使用列舉來建立一系列列舉數值的自訂型別。我們展示了標準函式庫的 Option<T> 型別如何用型別系統來預防錯誤。當列舉數值其內有資料時，你可以依照你想處理的情況數量，使用 match 或 if let 來取出並使用那些數值。
