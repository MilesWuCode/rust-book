# 透過字串儲存 UTF-8 編碼的文字

建立新的字串

建立新的空 String

```rust
fn main() {
    let mut s = String::new();
}
```

從字串字面值使用 to_string 方法來建立 String

```rust
fn main() {
    let data = "初始內容";

    let s = data.to_string();

    // 此方法也能直接用於字面值上
    let s = "初始內容".to_string();
}
```

使用函式 String::from 從字串字面值建立 String

```rust
fn main() {
    let s = String::from("初始內容");
}
```

更新字串

使用 push_str 方法向 String 追加字串切片

```rust
fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
}
```

在內容追加給 String 後繼續使用字串切片

push_str 方法取得的是字串切片因為我們並不需要取得參數的所有權。我們想在 s2 追加其內容給 s1 之後仍能使用。

```rust
fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
}
```

使用 push 將一個字元加到 String

```rust
fn main() {
    let mut s = String::from("lo");
    s.push('l'); // lol
}
```

使用 + 運算子或 format! 巨集串接字串

使用 + 運算子組合兩個 String 數值成一個新的 String 數值

```rust
fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // 注意到 s1 被移動因此無法再被使用
}
```

程式碼最後的字串 s3 就會獲得 Hello, world!。s1 之所以在相加後不再有效，以及 s2 是使用參考的原因，都和我們使用 + 運算子時呼叫的方法簽名有關。

```rust
fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
}
```

索引字串

```rust
#![allow(unused)]
fn main() {
    for c in "Зд".chars() {
        println!("{c}");
    }
}

#![allow(unused)]
fn main() {
    for b in "Зд".bytes() {
        println!("{b}");
    }
}
```
