# 定義列舉

IpAddrKind 現在成了能在我們程式碼任何地方使用的自訂資料型別。

```rust
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    // 列舉數值
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    // 然後我們可以用任意變體呼叫此函式
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

fn route(ip_kind: IpAddrKind) {}
```

使用 struct 儲存 IP 位址的資料與 IpAddrKind 的變體

```rust
fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
}
```

我們可以用另一種更簡潔的方式來定義列舉就好，而不必使用結構體加上列舉。列舉內的每個變體其實都能擁有數值。

我們將資料直接附加到列舉的每個變體上，這樣就不再用結構體。這裏我們還能看到另一項列舉的細節：我們定義的每一個列舉變體也會變成建構該列舉的函式。也就是說 IpAddr::V4() 是個函式，且接收 String 引數並回傳 IpAddr 的實例。我們在定義列舉時就會自動拿到這樣的建構函式。

```rust
fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
}
```

改使用列舉而非結構體的話還有另一項好處：每個變體可以擁有不同型別與資料的數量。第四版的 IP 位址永遠只會有四個 0 到 255 的數字部分，如果我們想要讓 V4 儲存四個 u8，但 V6 位址仍保持 String 不變的話，我們在結構體是無法做到的。

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
}
```

列舉和結構體還有一個地方很像：如同我們可以對結構體使用 impl 定義方法，我們也可以對列舉定義方法。以下範例顯示我們可以對 Message 列舉定義一個 call 方法

方法本體使用 self 來取得我們呼叫方法的值。在此例中，我們建立了一個變數 m 並取得 Message::Write(String::from("hello"))，而這就會是當我們執行 m.call() 時 call 方法內會用到的 self。

```rust
fn main() {
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    impl Message {
        fn call(&self) {
            // 在此定義方法本體
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
}
```

Option 列舉相對於空值的優勢

Option 廣泛運用在許多場合，它能表示一個數值可能有某個東西，或者什麼都沒有。

它是在標準函式庫中這樣定義的

```rust
#![allow(unused)]
fn main() {
enum Option<T> {
    None,
    Some(T),
}
}
```

some_number 的型別是 Option<i32>，而 some_char 的型別是 Option<char>，兩者是不同的型別。Rust 可以推導出這些型別，因為我們已經在 Some 變體指定數值。至於 absent_number 的話，Rust 需要我們寫出完整的 Option 型別，因為編譯器無法從 None 推導出相對應的 Some 變體會持有哪種型別。我們在這裡告訴 Rust 我們 absent_number 所指的型別為 Option<i32>。

```rust
fn main() {
    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option<i32> = None;
}
```
