# 切片型別 slices

切片（slice） 讓你可以參考一串集合中的元素序列，而並非參考整個集合。切片也算是某種類型的參考，所以它沒有所有權。

函式 first_word 回傳參數 String 第一個單字最後的索引

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes(); // 遍歷 String 的每個元素並檢查該值是否為空格，as_bytes 方法將 String 轉換成一個位元組陣列

    // iter 方法對位元組陣列建立一個疊代器（iterator）

    // enumerate 會將 iter 的結果包裝起來回傳成元組

    // enumerate 回傳的元組中的第一個元素是索引，第二個才是元素的參考。這樣比我們自己計算索引還來的方便。

    // 在 for 迴圈中，我們指定了一個模式讓 i 取得索引然後 &item 取得元組中的位元組。因為我們從用 .iter().enumerate() 取得參考的，所以在模式中我們用的是 & 來獲取。
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i; // 如果我們找到空格的話，我們就回傳該位置。
        }
    }

    s.len() // 回傳整個字串的長度
}

fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word 取得數值 5

    s.clear(); // 這會清空 String，這就等於 ""

    // word 仍然是數值 5 ，但是我們已經沒有相等意義的字串了
    // 擁有 5 的變數 word 現在完全沒意義！
}
```

字串切片

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5]; // 起始到結尾位置
    let world = &s[6..11];

    let slice = &s[0..2];
    let slice = &s[..2]; // 相同

    let len = s.len();

    let slice = &s[3..len];
    let slice = &s[3..]; // 相同

    let slice = &s[0..len];
    let slice = &s[..]; // 相同
}
```

有了這些資訊，讓我們用切片來重寫 first_word 吧。對於「字串切片」的回傳型別我們會寫 &str

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

// 同時接受 &String 和 &str 的數值。
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

定義函式的參數為字串切片而非 String 可以讓我們的 API 更通用且不會失去任何功能

```rust
fn main() {
    let my_string = String::from("hello world");

    // first_word 適用於 `String` 的切片，無論是部分或整體
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // first_word 也適用於 `String` 的參考，這等同於對整個 `String` 切片的操作。
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // first_word 適用於字串字面值，無論是部分或整體
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // 因為字串字面值本來就是切片
    // 沒有切片語法也是可行的！
    let word = first_word(my_string_literal);
}
```

其他切片

```rust
#![allow(unused)]
fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
}
```
